name: Infrastructure Deployment

on:
  push:
    paths:
      - 'infra/terraform/**'
      - 'infra/ansible/**'
  pull_request:
    paths:
      - 'infra/terraform/**'
      - 'infra/ansible/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, stg, prod)'
        required: true
        type: choice
        options:
          - dev
          - stg
          - prod
        default: 'dev'

# Prevent duplicate runs - cancel in-progress runs when a new one starts
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: true

jobs:
  terraform-plan:
    name: Terraform Plan & Drift Detection (${{ github.event.inputs.environment || 'dev' }})
    runs-on: ubuntu-latest
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      drift_detected: ${{ steps.drift-check.outputs.drift_detected }}
      server_ip: ${{ steps.get-server-ip.outputs.server_ip }}
      ansible_files_changed: ${{ steps.file-changes-check.outputs.ansible_files_changed }}
      infrastructure_changed: ${{ steps.drift-check.outputs.infrastructure_changed }}
      change_type: ${{ steps.drift-check.outputs.change_type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch at least 2 commits to enable diff with previous commit

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure S3 Backend
        id: backend-config
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          echo "Configuring S3 backend for environment: $ENV"
          
          # Set backend configuration from secrets (per environment)
          BACKEND_BUCKET="${{ secrets.TERRAFORM_STATE_BUCKET }}"
          BACKEND_KEY="terraform-state/${ENV}/terraform.tfstate"
          BACKEND_REGION="${{ secrets.AWS_REGION || 'us-east-1' }}"
          BACKEND_DYNAMODB_TABLE="${{ secrets.TERRAFORM_STATE_LOCK_TABLE }}"
          
          echo "Backend Bucket: $BACKEND_BUCKET"
          echo "Backend Key: $BACKEND_KEY"
          echo "Backend Region: $BACKEND_REGION"
          echo "DynamoDB Table: $BACKEND_DYNAMODB_TABLE"
          
          if [ -z "$BACKEND_BUCKET" ] || [ -z "$BACKEND_DYNAMODB_TABLE" ]; then
            echo "âš ï¸  WARNING: Backend bucket or DynamoDB table not configured in secrets"
            echo "Using local backend (not recommended for production)"
            echo "backend_configured=false" >> $GITHUB_OUTPUT
          else
            echo "backend_configured=true" >> $GITHUB_OUTPUT
            echo "backend_bucket=$BACKEND_BUCKET" >> $GITHUB_OUTPUT
            echo "backend_key=$BACKEND_KEY" >> $GITHUB_OUTPUT
            echo "backend_region=$BACKEND_REGION" >> $GITHUB_OUTPUT
            echo "backend_table=$BACKEND_DYNAMODB_TABLE" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Init (with remote backend)
        if: steps.backend-config.outputs.backend_configured == 'true'
        working-directory: infra/terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ steps.backend-config.outputs.backend_bucket }}" \
            -backend-config="key=${{ steps.backend-config.outputs.backend_key }}" \
            -backend-config="region=${{ steps.backend-config.outputs.backend_region }}" \
            -backend-config="dynamodb_table=${{ steps.backend-config.outputs.backend_table }}" \
            -backend-config="encrypt=true"

      - name: Terraform Init (local backend fallback)
        if: steps.backend-config.outputs.backend_configured != 'true'
        working-directory: infra/terraform
        run: |
          echo "âš ï¸  Using local backend (configure S3 backend in secrets for production)"
          terraform init -backend=false

      - name: Remove null_resource from state if exists (for count transition)
        working-directory: infra/terraform
        run: |
          if [ -f terraform.tfstate ]; then
            # Remove null_resource from state if it exists (handles transition to count-based resource)
            terraform state list 2>/dev/null | grep -E "null_resource.ansible_provision(\[0\])?$" | while read resource; do
              echo "Removing $resource from state..."
              terraform state rm "$resource" || true
            done
          fi
        continue-on-error: true

      - name: Use environment-specific tfvars
        id: use-tfvars
        working-directory: infra/terraform
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          TFVARS_FILE="terraform.${ENV}.tfvars"
          
          if [ ! -f "$TFVARS_FILE" ]; then
            echo "âŒ Error: $TFVARS_FILE not found"
            echo "Available files:"
            ls -la terraform.*.tfvars 2>/dev/null || echo "No environment tfvars files found"
            exit 1
          fi
          
          echo "âœ… Using $TFVARS_FILE for environment: $ENV"
          echo "tfvars_file=$TFVARS_FILE" >> $GITHUB_OUTPUT

      - name: Import existing security group (if exists)
        working-directory: infra/terraform
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          SG_NAME="todo-app-sg-${ENV}"
          
          # Try to find existing security group by name (environment-specific)
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=$SG_NAME" \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            echo "Found existing security group: $SG_ID"
            # Check if already in state
            if ! terraform state show aws_security_group.todo_app 2>/dev/null; then
              echo "Importing existing security group into Terraform state..."
              terraform import -var-file=${{ steps.use-tfvars.outputs.tfvars_file }} -var="key_pair_name=${{ secrets.TERRAFORM_KEY_PAIR_NAME }}" aws_security_group.todo_app "$SG_ID" || echo "Import failed, will create new one"
            else
              echo "Security group already in Terraform state"
            fi
          else
            echo "No existing security group found"
          fi
        continue-on-error: true

      - name: Check for duplicate instances
        working-directory: infra/terraform
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          INSTANCE_NAME="todo-app-server-${ENV}"
          
          # Check for multiple instances with the same tag (environment-specific)
          INSTANCE_COUNT=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'length(Reservations[*].Instances[*])' \
            --output text 2>/dev/null || echo "0")
          
          if [ "$INSTANCE_COUNT" -gt 1 ]; then
            echo "âš ï¸  WARNING: Found $INSTANCE_COUNT instances with tag Name=todo-app-server!"
            echo ""
            echo "This indicates duplicate instances. Listing all instances:"
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
              --query 'Reservations[*].Instances[*].[InstanceId,State.Name,LaunchTime,PublicIpAddress]' \
              --output table 2>/dev/null || true
            echo ""
            echo "Possible causes:"
            echo "1. Terraform lifecycle 'create_before_destroy' created a new instance"
            echo "2. Import failed previously, causing Terraform to create a duplicate"
            echo "3. Manual instance creation outside of Terraform"
            echo ""
            echo "The import step will attempt to import the most recent instance."
            echo "You may need to manually terminate the older duplicate instance(s)."
          elif [ "$INSTANCE_COUNT" -eq 1 ]; then
            echo "âœ… Found exactly 1 instance (expected)"
          else
            echo "â„¹ï¸  No existing instances found (first run)"
          fi
        continue-on-error: true

      - name: Import existing EC2 instance (if exists)
        working-directory: infra/terraform
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          INSTANCE_NAME="todo-app-server-${ENV}"
          
          # Check for ALL instances with the tag (environment-specific)
          ALL_INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'Reservations[*].Instances[*].[InstanceId,State.Name,LaunchTime]' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$ALL_INSTANCES" ]; then
            echo "No existing EC2 instance found"
            exit 0
          fi
          
          # Count instances
          INSTANCE_COUNT=$(echo "$ALL_INSTANCES" | wc -l | tr -d ' ')
          
          if [ "$INSTANCE_COUNT" -gt 1 ]; then
            echo "âš ï¸  WARNING: Found $INSTANCE_COUNT instances with tag Name=todo-app-server!"
            echo "This might indicate duplicate instances. Listing all instances:"
            echo "$ALL_INSTANCES" | while read INSTANCE_ID STATE LAUNCH_TIME; do
              echo "  - Instance ID: $INSTANCE_ID, State: $STATE, Launch Time: $LAUNCH_TIME"
            done
            echo ""
            echo "Selecting the most recent RUNNING instance, or oldest if none are running..."
          fi
          
          # Try to find existing EC2 instance by tag (environment-specific)
          # Prefer running instances, then stopped, then others
          # Get the most recent one
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'Reservations[*].Instances[*].[InstanceId,State.Name,LaunchTime]' \
            --output text 2>/dev/null | \
            sort -k3 -r | \
            awk '{print $1}' | \
            head -1 || echo "")
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
            echo "No valid EC2 instance found to import"
            exit 0
          fi
          
          echo "Found existing EC2 instance: $INSTANCE_ID"
          
          # Check if already in state
          if terraform state show aws_instance.todo_app 2>/dev/null | grep -q "id.*=.*$INSTANCE_ID"; then
            echo "EC2 instance $INSTANCE_ID is already in Terraform state"
          elif terraform state show aws_instance.todo_app 2>/dev/null; then
            echo "âš ï¸  WARNING: Terraform state contains a different instance ID!"
            echo "This might cause Terraform to create a duplicate instance."
            echo "Current state instance: $(terraform state show aws_instance.todo_app 2>/dev/null | grep '^id' | awk '{print $3}' || echo 'unknown')"
            echo "Found instance: $INSTANCE_ID"
            echo ""
            echo "Attempting to import the found instance anyway..."
            terraform import -var-file=${{ steps.use-tfvars.outputs.tfvars_file }} -var="key_pair_name=${{ secrets.TERRAFORM_KEY_PAIR_NAME }}" aws_instance.todo_app "$INSTANCE_ID" || {
              echo "âŒ Import failed. This might cause Terraform to create a duplicate instance."
              echo "Please manually resolve the duplicate instances before proceeding."
              exit 1
            }
          else
            echo "Importing existing EC2 instance into Terraform state..."
            terraform import -var-file=${{ steps.use-tfvars.outputs.tfvars_file }} -var="key_pair_name=${{ secrets.TERRAFORM_KEY_PAIR_NAME }}" aws_instance.todo_app "$INSTANCE_ID" || {
              echo "âŒ Import failed. This might cause Terraform to create a duplicate instance."
              echo "Please check AWS console and manually resolve before proceeding."
              exit 1
            }
          fi
          
          # Note: EBS volume imports removed - using S3 remote backend instead
        continue-on-error: true

      - name: Remove existing null_resource from state (if needed)
        working-directory: infra/terraform
        run: |
          # Remove null_resource from state if it exists (when switching from count=1 to count=0)
          terraform state list 2>/dev/null | grep -q "null_resource.ansible_provision" && \
            terraform state rm null_resource.ansible_provision 2>/dev/null || \
            echo "null_resource.ansible_provision not in state or already removed"
        continue-on-error: true

      - name: Detect File Changes
        id: file-changes-check
        run: |
          echo "Checking if Terraform or Ansible files changed in this commit/PR..."
          
          TERRAFORM_FILES_CHANGED=""
          ANSIBLE_FILES_CHANGED=""
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            BASE_REF="${{ github.event.pull_request.base.ref }}"
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
            echo "PR: Comparing $HEAD_REF with $BASE_REF"
            
            # Fetch base branch to compare
            git fetch origin "$BASE_REF" --depth=1 2>/dev/null || true
            
            TERRAFORM_FILES_CHANGED=$(git diff --name-only "origin/$BASE_REF" "$HEAD_REF" 2>/dev/null | grep -E '^infra/terraform/' || echo "")
            ANSIBLE_FILES_CHANGED=$(git diff --name-only "origin/$BASE_REF" "$HEAD_REF" 2>/dev/null | grep -E '^infra/ansible/' || echo "")
          elif [ "${{ github.event_name }}" == "push" ]; then
            # For pushes, compare with previous commit
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BEFORE="${{ github.event.before }}"
              AFTER="${{ github.sha }}"
              echo "Push: Comparing $BEFORE with $AFTER"
              
              # Fetch the before commit if not available (for shallow clones)
              git fetch origin "$BEFORE" --depth=1 2>/dev/null || true
              
              # Try diff with commit hashes first
              TERRAFORM_FILES_CHANGED=$(git diff --name-only "$BEFORE" "$AFTER" 2>/dev/null | grep -E '^infra/terraform/' || echo "")
              ANSIBLE_FILES_CHANGED=$(git diff --name-only "$BEFORE" "$AFTER" 2>/dev/null | grep -E '^infra/ansible/' || echo "")
              
              # If that failed, try with HEAD~1 (fallback for shallow clones)
              if [ -z "$TERRAFORM_FILES_CHANGED" ] && [ -z "$ANSIBLE_FILES_CHANGED" ]; then
                echo "Warning: Could not diff with $BEFORE, trying HEAD~1 as fallback"
                TERRAFORM_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/terraform/' || echo "")
                ANSIBLE_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/ansible/' || echo "")
              fi
            else
              # First commit or no before commit, check all files
              echo "First commit or no previous commit - checking all files"
              TERRAFORM_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/terraform/' || echo "")
              ANSIBLE_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/ansible/' || echo "")
              if [ -z "$TERRAFORM_FILES_CHANGED" ] && [ -z "$ANSIBLE_FILES_CHANGED" ]; then
                # If that fails, assume files changed (safer for first run)
                TERRAFORM_FILES_CHANGED="infra/terraform/"
                ANSIBLE_FILES_CHANGED="infra/ansible/"
              fi
            fi
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual runs, compare with last commit on same branch
            echo "Manual workflow dispatch: Comparing with last commit"
            TERRAFORM_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/terraform/' || echo "")
            ANSIBLE_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/ansible/' || echo "")
          fi
          
          if [ -n "$TERRAFORM_FILES_CHANGED" ]; then
            echo "âœ… Terraform files changed:"
            echo "$TERRAFORM_FILES_CHANGED" | sed 's/^/  - /'
            echo "terraform_files_changed=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸  No Terraform files changed in this commit/PR"
            echo "terraform_files_changed=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$ANSIBLE_FILES_CHANGED" ]; then
            echo "âœ… Ansible files changed:"
            echo "$ANSIBLE_FILES_CHANGED" | sed 's/^/  - /'
            echo "ansible_files_changed=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸  No Ansible files changed in this commit/PR"
            echo "ansible_files_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Plan
        working-directory: infra/terraform
        run: terraform plan -out=tfplan -var-file=${{ steps.use-tfvars.outputs.tfvars_file }} -var="key_pair_name=${{ secrets.TERRAFORM_KEY_PAIR_NAME }}"
        continue-on-error: true

      - name: Check for Drift
        id: drift-check
        working-directory: infra/terraform
        run: |
          # Check if this is a first run (check if state exists in remote backend)
          # With remote backend, we check by trying to list resources in state
          STATE_EXISTS=false
          if terraform state list 2>/dev/null | grep -q "aws_instance.todo_app"; then
            STATE_EXISTS=true
            echo "Existing state found in remote backend"
          else
            echo "No existing state found (first run)"
          fi
          
          if [ "$STATE_EXISTS" == "false" ]; then
            echo "First run detected - no existing state"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=true" >> $GITHUB_OUTPUT
            echo "change_type=first_run" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT  # First run always creates infrastructure
          elif [ ! -f tfplan ]; then
            echo "Warning: tfplan file not found (terraform plan may have failed)"
            echo "Assuming no infrastructure changes"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=none" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=false" >> $GITHUB_OUTPUT
          elif terraform show -no-color tfplan 2>/dev/null | grep -q "No changes"; then
            echo "No changes detected - infrastructure is in sync"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=none" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=false" >> $GITHUB_OUTPUT  # No infrastructure changes
          elif [ "${{ steps.file-changes-check.outputs.terraform_files_changed }}" == "true" ]; then
            echo "Terraform files were modified - these are expected changes, not drift"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=expected" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT  # Plan shows changes
            if [ -f tfplan ]; then
              terraform show -no-color tfplan > change_summary.txt 2>/dev/null || echo "Could not read tfplan" > change_summary.txt
              echo "ðŸ“ Change summary saved (expected changes from code updates)"
            fi
          else
            echo "ðŸš¨ REAL DRIFT DETECTED - Infrastructure changed outside Terraform!"
            echo "Terraform files did NOT change, but plan shows changes."
            echo "This means infrastructure was modified manually or by another process."
            echo "drift_detected=true" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=drift" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT  # Plan shows changes
            if [ -f tfplan ]; then
              terraform show -no-color tfplan > drift_summary.txt 2>/dev/null || echo "Could not read tfplan" > drift_summary.txt
              echo "ðŸš¨ Drift summary saved - requires immediate attention"
            fi
          fi

      - name: Get Server IP from State
        id: get-server-ip
        working-directory: infra/terraform
        run: |
          if [ -f terraform.tfstate ]; then
            SERVER_IP=$(terraform output -raw server_ip 2>/dev/null || echo "")
            if [ -z "$SERVER_IP" ]; then
              # Try to extract from state file
              SERVER_IP=$(grep -o '"public_ip":"[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
            fi
            echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          else
            echo "server_ip=" >> $GITHUB_OUTPUT
          fi

      - name: Send Drift Email (Real Drift Only)
        if: steps.drift-check.outputs.change_type == 'drift'
        run: |
          echo "ðŸš¨ Sending drift alert email..."
          chmod +x ./infra/ci-cd/scripts/email-notification.sh
          ./infra/ci-cd/scripts/email-notification.sh "$(cat infra/terraform/drift_summary.txt)"
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}

      - name: Log Expected Changes
        if: steps.drift-check.outputs.change_type == 'expected'
        run: |
          echo "â„¹ï¸  Expected changes detected (Terraform files were modified)"
          echo "Proceeding with deployment without drift alert..."
          echo ""
          echo "Changes will be applied:"
          echo "---"
          head -50 infra/terraform/change_summary.txt || echo "Change summary not available"

      - name: Manual Approval for Real Drift (Prod Only)
        if: steps.drift-check.outputs.change_type == 'drift' && env.ENVIRONMENT == 'prod'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          minimum-approvals: 1
          issue-title: "ðŸš¨ REAL DRIFT DETECTED - Infrastructure Changed Outside Terraform"
          issue-body: |
            **âš ï¸ CRITICAL: Real Infrastructure Drift Detected**
            
            Infrastructure has been modified **outside of Terraform**. This is unexpected and requires investigation.
            
            **What happened:**
            - Terraform code files were **NOT modified**
            - But infrastructure plan shows changes
            - This indicates manual changes or changes from another process
            
            **Action Required:**
            1. Review the plan below
            2. Investigate what caused the drift
            3. Approve if changes are intentional, or revert if unauthorized
            
            **Plan Summary:**
            ```
            ${{ steps.drift-check.outputs.drift_summary }}
            ```
            
            **Note:** No Terraform files were changed in this commit, confirming this is real drift.
            
            **Next Steps:**
            - Approve to apply these changes
            - Or investigate and revert unauthorized changes
          issue-create-on-fail: false
        continue-on-error: true
        id: manual-approval

      - name: Log first run
        if: steps.drift-check.outputs.change_type == 'first_run'
        run: |
          echo "âœ… First infrastructure deployment - proceeding without approval"

      - name: Terraform Apply
        if: |
          steps.drift-check.outputs.change_type == 'first_run' ||
          steps.drift-check.outputs.change_type == 'none' ||
          steps.drift-check.outputs.change_type == 'expected' ||
          (steps.drift-check.outputs.change_type == 'drift' && env.ENVIRONMENT != 'prod') ||
          (steps.drift-check.outputs.change_type == 'drift' && env.ENVIRONMENT == 'prod' && steps.manual-approval.outcome == 'success')
        working-directory: infra/terraform
        run: |
          if [ "${{ steps.drift-check.outputs.change_type }}" == "drift" ]; then
            echo "âš ï¸  Applying changes after drift approval..."
          elif [ "${{ steps.drift-check.outputs.change_type }}" == "expected" ]; then
            echo "âœ… Applying expected changes from Terraform code updates..."
          elif [ "${{ steps.drift-check.outputs.change_type }}" == "first_run" ]; then
            echo "ðŸš€ Applying first infrastructure deployment..."
          else
            echo "â„¹ï¸  No changes to apply"
          fi
          terraform apply -auto-approve tfplan

      - name: Upload Terraform State
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/terraform.tfstate
          retention-days: 90  # Increased from 1 to 90 days to prevent state loss
          if-no-files-found: ignore

  ansible-deploy:
    name: Ansible Deployment (${{ github.event.inputs.environment || 'dev' }})
    runs-on: ubuntu-latest
    needs: terraform-plan
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
    # Only run Ansible if:
    # 1. Ansible files changed (playbook/roles updated), OR
    # 2. Infrastructure actually changed (new instance, etc.), OR
    # 3. First run (infrastructure being created for the first time)
    if: |
      needs.terraform-plan.outputs.ansible_files_changed == 'true' ||
      needs.terraform-plan.outputs.infrastructure_changed == 'true' ||
      needs.terraform-plan.outputs.change_type == 'first_run'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/
          if-no-files-found: ignore
        continue-on-error: true

      - name: Get Server IP from Terraform Output
        id: get-server-ip
        working-directory: infra/terraform
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          INSTANCE_NAME="todo-app-server-${ENV}"
          
          # Try to get server IP from Terraform output (works with remote backend)
          echo "Initializing Terraform to access remote state..."
          BACKEND_BUCKET="${{ secrets.TERRAFORM_STATE_BUCKET }}"
          BACKEND_KEY="terraform-state/${ENV}/terraform.tfstate"
          BACKEND_REGION="${{ secrets.AWS_REGION || 'us-east-1' }}"
          BACKEND_DYNAMODB_TABLE="${{ secrets.TERRAFORM_STATE_LOCK_TABLE }}"
          
          SERVER_IP=""
          
          if [ -n "$BACKEND_BUCKET" ] && [ -n "$BACKEND_DYNAMODB_TABLE" ]; then
            echo "Initializing with remote backend to read outputs..."
            terraform init \
              -backend-config="bucket=$BACKEND_BUCKET" \
              -backend-config="key=$BACKEND_KEY" \
              -backend-config="region=$BACKEND_REGION" \
              -backend-config="dynamodb_table=$BACKEND_DYNAMODB_TABLE" \
              -backend-config="encrypt=true" \
              -reconfigure || true
            
            # Try to get server IP from Terraform output
            echo "Trying Terraform output from remote state..."
            SERVER_IP=$(terraform output -raw server_ip 2>/dev/null || echo "")
            echo "Terraform output result: '$SERVER_IP'"
          fi
          
          # Fallback: Query AWS directly - find by tag (environment-specific)
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ] || [ "$SERVER_IP" == "None" ]; then
            echo "Querying AWS for server IP by tag (environment: $ENV)..."
            # Find instance by tag (environment-specific)
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ] && [ "$INSTANCE_ID" != "null" ]; then
              echo "Found instance by tag: $INSTANCE_ID"
              SERVER_IP=$(aws ec2 describe-instances \
                --instance-ids "$INSTANCE_ID" \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text 2>/dev/null || echo "")
              echo "AWS query by tag result: '$SERVER_IP'"
            else
              echo "No instance found with tag Name=$INSTANCE_NAME"
            fi
          fi
          
          # Final validation
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ] || [ "$SERVER_IP" == "None" ] || [ "$SERVER_IP" == "-" ]; then
            echo "ERROR: Could not determine server IP address"
            echo "Debugging info:"
            echo "Environment: $ENV"
            echo "Instance name filter: $INSTANCE_NAME"
            echo "Backend configured: $([ -n "$BACKEND_BUCKET" ] && echo 'yes' || echo 'no')"
            echo ""
            echo "Listing all instances with 'todo-app-server' in name:"
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=todo-app-server*" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
              --query 'Reservations[*].Instances[*].[InstanceId,Tags[?Key==`Name`].Value|[0],State.Name,PublicIpAddress]' \
              --output table 2>/dev/null || echo "Could not list instances"
            exit 1
          fi
          
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "âœ“ Server IP: $SERVER_IP"

      - name: Setup SSH
        run: |
          if [ -z "${{ steps.get-server-ip.outputs.server_ip }}" ]; then
            echo "ERROR: Server IP is empty. Cannot setup SSH."
            exit 1
          fi
          
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-server-ip.outputs.server_ip }} >> ~/.ssh/known_hosts

      - name: Install Ansible
        # Ansible is required for deployment, but GitHub Actions runners are ephemeral
        # so we need to install it each time. However, we can optimize by using pip
        # which is faster than apt-get, or check if it's already available.
        run: |
          if ! command -v ansible &> /dev/null; then
            echo "Installing Ansible..."
            sudo apt-get update -qq
            sudo apt-get install -y ansible
          else
            echo "Ansible already installed: $(ansible --version | head -1)"
          fi

      - name: Generate Ansible Inventory
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          mkdir -p infra/ansible/inventory
          cat > infra/ansible/inventory/${ENV}.yml <<EOF
          all:
            hosts:
              todo-app-server:
                ansible_host: ${{ steps.get-server-ip.outputs.server_ip }}
                ansible_user: ubuntu
                ansible_ssh_private_key_file: ~/.ssh/id_rsa
                ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
          EOF
          echo "Generated inventory file for environment $ENV:"
          cat infra/ansible/inventory/${ENV}.yml

      - name: Wait for SSH
        run: |
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@${{ steps.get-server-ip.outputs.server_ip }} 'echo "SSH ready"'; then
              echo "SSH is ready!"
              exit 0
            fi
            echo "Attempt $i/30: SSH not ready yet, waiting 10 seconds..."
            sleep 10
          done
          echo "SSH failed to become available"
          exit 1

      - name: Run Ansible Playbook
        run: |
          ENV="${{ env.ENVIRONMENT }}"
          cd infra/ansible
          ansible-playbook -i inventory/${ENV}.yml playbook.yml -e "environment=${ENV}"
        env:
          ANSIBLE_HOST_KEY_CHECKING: False
          ANSIBLE_SSH_PRIVATE_KEY_FILE: ~/.ssh/id_rsa

