name: Infrastructure Deployment

on:
  push:
    paths:
      - 'infra/terraform/**'
      - 'infra/ansible/**'
  pull_request:
    paths:
      - 'infra/terraform/**'
      - 'infra/ansible/**'
  workflow_dispatch:

# Prevent duplicate runs - cancel in-progress runs when a new one starts
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  terraform-plan:
    name: Terraform Plan & Drift Detection
    runs-on: ubuntu-latest
    outputs:
      drift_detected: ${{ steps.drift-check.outputs.drift_detected }}
      server_ip: ${{ steps.get-server-ip.outputs.server_ip }}
      ansible_files_changed: ${{ steps.file-changes-check.outputs.ansible_files_changed }}
      infrastructure_changed: ${{ steps.drift-check.outputs.infrastructure_changed }}
      change_type: ${{ steps.drift-check.outputs.change_type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch at least 2 commits to enable diff with previous commit

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: Remove null_resource from state if exists (for count transition)
        working-directory: infra/terraform
        run: |
          if [ -f terraform.tfstate ]; then
            # Remove null_resource from state if it exists (handles transition to count-based resource)
            terraform state list 2>/dev/null | grep -E "null_resource.ansible_provision(\[0\])?$" | while read resource; do
              echo "Removing $resource from state..."
              terraform state rm "$resource" || true
            done
          fi
        continue-on-error: true

      - name: Create terraform.tfvars from GitHub Secrets
        working-directory: infra/terraform
        run: |
            cat > terraform.tfvars <<EOF
            aws_region = "${{ secrets.AWS_REGION || 'us-east-1' }}"
            instance_type = "${{ secrets.TERRAFORM_INSTANCE_TYPE || 't3.medium' }}"
            key_pair_name = "${{ secrets.TERRAFORM_KEY_PAIR_NAME }}"
            ssh_key_path = "${{ secrets.TERRAFORM_SSH_KEY_PATH || '~/.ssh/id_rsa' }}"
            ssh_cidr = "${{ secrets.TERRAFORM_SSH_CIDR || '0.0.0.0/0' }}"
            server_user = "${{ secrets.TERRAFORM_SERVER_USER || 'ubuntu' }}"
            state_volume_size = ${{ secrets.TERRAFORM_STATE_VOLUME_SIZE || 10 }}
            availability_zone = ""
            skip_ansible_provision = true
            EOF

      - name: Import existing security group (if exists)
        working-directory: infra/terraform
        run: |
          # Try to find existing security group by name
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=todo-app-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            echo "Found existing security group: $SG_ID"
            # Check if already in state
            if ! terraform state show aws_security_group.todo_app 2>/dev/null; then
              echo "Importing existing security group into Terraform state..."
              terraform import -var-file=terraform.tfvars aws_security_group.todo_app "$SG_ID" || echo "Import failed, will create new one"
            else
              echo "Security group already in Terraform state"
            fi
          else
            echo "No existing security group found"
          fi
        continue-on-error: true

      - name: Check for duplicate instances
        working-directory: infra/terraform
        run: |
          # Check for multiple instances with the same tag
          INSTANCE_COUNT=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=todo-app-server" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'length(Reservations[*].Instances[*])' \
            --output text 2>/dev/null || echo "0")
          
          if [ "$INSTANCE_COUNT" -gt 1 ]; then
            echo "âš ï¸  WARNING: Found $INSTANCE_COUNT instances with tag Name=todo-app-server!"
            echo ""
            echo "This indicates duplicate instances. Listing all instances:"
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=todo-app-server" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
              --query 'Reservations[*].Instances[*].[InstanceId,State.Name,LaunchTime,PublicIpAddress]' \
              --output table 2>/dev/null || true
            echo ""
            echo "Possible causes:"
            echo "1. Terraform lifecycle 'create_before_destroy' created a new instance"
            echo "2. Import failed previously, causing Terraform to create a duplicate"
            echo "3. Manual instance creation outside of Terraform"
            echo ""
            echo "The import step will attempt to import the most recent instance."
            echo "You may need to manually terminate the older duplicate instance(s)."
          elif [ "$INSTANCE_COUNT" -eq 1 ]; then
            echo "âœ… Found exactly 1 instance (expected)"
          else
            echo "â„¹ï¸  No existing instances found (first run)"
          fi
        continue-on-error: true

      - name: Import existing EC2 instance (if exists)
        working-directory: infra/terraform
        run: |
          # Check for ALL instances with the tag (not just the first one)
          ALL_INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=todo-app-server" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'Reservations[*].Instances[*].[InstanceId,State.Name,LaunchTime]' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$ALL_INSTANCES" ]; then
            echo "No existing EC2 instance found"
            exit 0
          fi
          
          # Count instances
          INSTANCE_COUNT=$(echo "$ALL_INSTANCES" | wc -l | tr -d ' ')
          
          if [ "$INSTANCE_COUNT" -gt 1 ]; then
            echo "âš ï¸  WARNING: Found $INSTANCE_COUNT instances with tag Name=todo-app-server!"
            echo "This might indicate duplicate instances. Listing all instances:"
            echo "$ALL_INSTANCES" | while read INSTANCE_ID STATE LAUNCH_TIME; do
              echo "  - Instance ID: $INSTANCE_ID, State: $STATE, Launch Time: $LAUNCH_TIME"
            done
            echo ""
            echo "Selecting the most recent RUNNING instance, or oldest if none are running..."
          fi
          
          # Try to find existing EC2 instance by tag Name=todo-app-server
          # Prefer running instances, then stopped, then others
          # Get the most recent one
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=todo-app-server" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'Reservations[*].Instances[*].[InstanceId,State.Name,LaunchTime]' \
            --output text 2>/dev/null | \
            sort -k3 -r | \
            awk '{print $1}' | \
            head -1 || echo "")
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
            echo "No valid EC2 instance found to import"
            exit 0
          fi
          
          echo "Found existing EC2 instance: $INSTANCE_ID"
          
          # Check if already in state
          if terraform state show aws_instance.todo_app 2>/dev/null | grep -q "id.*=.*$INSTANCE_ID"; then
            echo "EC2 instance $INSTANCE_ID is already in Terraform state"
          elif terraform state show aws_instance.todo_app 2>/dev/null; then
            echo "âš ï¸  WARNING: Terraform state contains a different instance ID!"
            echo "This might cause Terraform to create a duplicate instance."
            echo "Current state instance: $(terraform state show aws_instance.todo_app 2>/dev/null | grep '^id' | awk '{print $3}' || echo 'unknown')"
            echo "Found instance: $INSTANCE_ID"
            echo ""
            echo "Attempting to import the found instance anyway..."
            terraform import -var-file=terraform.tfvars aws_instance.todo_app "$INSTANCE_ID" || {
              echo "âŒ Import failed. This might cause Terraform to create a duplicate instance."
              echo "Please manually resolve the duplicate instances before proceeding."
              exit 1
            }
          else
            echo "Importing existing EC2 instance into Terraform state..."
            terraform import -var-file=terraform.tfvars aws_instance.todo_app "$INSTANCE_ID" || {
              echo "âŒ Import failed. This might cause Terraform to create a duplicate instance."
              echo "Please check AWS console and manually resolve before proceeding."
              exit 1
            }
          fi
          
          # Also check for and import associated EBS volume if it exists
          echo "Checking for associated EBS volume..."
          VOL_ID=$(aws ec2 describe-volumes \
            --filters "Name=attachment.instance-id,Values=$INSTANCE_ID" "Name=tag:Name,Values=terraform-state-storage" \
            --query 'Volumes[0].VolumeId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$VOL_ID" ] && [ "$VOL_ID" != "None" ]; then
            echo "Found associated EBS volume: $VOL_ID"
            # Import EBS volume if not in state
            if ! terraform state show aws_ebs_volume.terraform_state 2>/dev/null; then
              echo "Importing EBS volume into Terraform state..."
              terraform import -var-file=terraform.tfvars aws_ebs_volume.terraform_state "$VOL_ID" || echo "EBS volume import failed (non-critical)"
            fi
            # Import volume attachment format: <volume_id>:<instance_id>:<device>
            if ! terraform state show aws_volume_attachment.terraform_state 2>/dev/null; then
              DEVICE=$(aws ec2 describe-volumes --volume-ids "$VOL_ID" --query 'Volumes[0].Attachments[0].Device' --output text 2>/dev/null || echo "/dev/sdf")
              echo "Importing volume attachment: $VOL_ID:$INSTANCE_ID:$DEVICE"
              terraform import -var-file=terraform.tfvars aws_volume_attachment.terraform_state "${VOL_ID}:${INSTANCE_ID}:${DEVICE}" || echo "Volume attachment import failed (non-critical)"
            fi
          fi
        continue-on-error: true

      - name: Remove existing null_resource from state (if needed)
        working-directory: infra/terraform
        run: |
          # Remove null_resource from state if it exists (when switching from count=1 to count=0)
          terraform state list 2>/dev/null | grep -q "null_resource.ansible_provision" && \
            terraform state rm null_resource.ansible_provision 2>/dev/null || \
            echo "null_resource.ansible_provision not in state or already removed"
        continue-on-error: true

      - name: Detect File Changes
        id: file-changes-check
        run: |
          echo "Checking if Terraform or Ansible files changed in this commit/PR..."
          
          TERRAFORM_FILES_CHANGED=""
          ANSIBLE_FILES_CHANGED=""
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            BASE_REF="${{ github.event.pull_request.base.ref }}"
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
            echo "PR: Comparing $HEAD_REF with $BASE_REF"
            
            # Fetch base branch to compare
            git fetch origin "$BASE_REF" --depth=1 2>/dev/null || true
            
            TERRAFORM_FILES_CHANGED=$(git diff --name-only "origin/$BASE_REF" "$HEAD_REF" 2>/dev/null | grep -E '^infra/terraform/' || echo "")
            ANSIBLE_FILES_CHANGED=$(git diff --name-only "origin/$BASE_REF" "$HEAD_REF" 2>/dev/null | grep -E '^infra/ansible/' || echo "")
          elif [ "${{ github.event_name }}" == "push" ]; then
            # For pushes, compare with previous commit
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BEFORE="${{ github.event.before }}"
              AFTER="${{ github.sha }}"
              echo "Push: Comparing $BEFORE with $AFTER"
              
              # Fetch the before commit if not available (for shallow clones)
              git fetch origin "$BEFORE" --depth=1 2>/dev/null || true
              
              # Try diff with commit hashes first
              TERRAFORM_FILES_CHANGED=$(git diff --name-only "$BEFORE" "$AFTER" 2>/dev/null | grep -E '^infra/terraform/' || echo "")
              ANSIBLE_FILES_CHANGED=$(git diff --name-only "$BEFORE" "$AFTER" 2>/dev/null | grep -E '^infra/ansible/' || echo "")
              
              # If that failed, try with HEAD~1 (fallback for shallow clones)
              if [ -z "$TERRAFORM_FILES_CHANGED" ] && [ -z "$ANSIBLE_FILES_CHANGED" ]; then
                echo "Warning: Could not diff with $BEFORE, trying HEAD~1 as fallback"
                TERRAFORM_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/terraform/' || echo "")
                ANSIBLE_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/ansible/' || echo "")
              fi
            else
              # First commit or no before commit, check all files
              echo "First commit or no previous commit - checking all files"
              TERRAFORM_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/terraform/' || echo "")
              ANSIBLE_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/ansible/' || echo "")
              if [ -z "$TERRAFORM_FILES_CHANGED" ] && [ -z "$ANSIBLE_FILES_CHANGED" ]; then
                # If that fails, assume files changed (safer for first run)
                TERRAFORM_FILES_CHANGED="infra/terraform/"
                ANSIBLE_FILES_CHANGED="infra/ansible/"
              fi
            fi
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual runs, compare with last commit on same branch
            echo "Manual workflow dispatch: Comparing with last commit"
            TERRAFORM_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/terraform/' || echo "")
            ANSIBLE_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^infra/ansible/' || echo "")
          fi
          
          if [ -n "$TERRAFORM_FILES_CHANGED" ]; then
            echo "âœ… Terraform files changed:"
            echo "$TERRAFORM_FILES_CHANGED" | sed 's/^/  - /'
            echo "terraform_files_changed=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸  No Terraform files changed in this commit/PR"
            echo "terraform_files_changed=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$ANSIBLE_FILES_CHANGED" ]; then
            echo "âœ… Ansible files changed:"
            echo "$ANSIBLE_FILES_CHANGED" | sed 's/^/  - /'
            echo "ansible_files_changed=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸  No Ansible files changed in this commit/PR"
            echo "ansible_files_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Plan
        working-directory: infra/terraform
        run: terraform plan -out=tfplan -var-file=terraform.tfvars
        continue-on-error: true

      - name: Check for Drift
        id: drift-check
        working-directory: infra/terraform
        run: |
          # Check if this is a first run (no existing state)
          if [ ! -f terraform.tfstate ] || [ ! -s terraform.tfstate ]; then
            echo "First run detected - no existing state"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=true" >> $GITHUB_OUTPUT
            echo "change_type=first_run" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT  # First run always creates infrastructure
          elif [ ! -f tfplan ]; then
            echo "Warning: tfplan file not found (terraform plan may have failed)"
            echo "Assuming no infrastructure changes"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=none" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=false" >> $GITHUB_OUTPUT
          elif terraform show -no-color tfplan 2>/dev/null | grep -q "No changes"; then
            echo "No changes detected - infrastructure is in sync"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=none" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=false" >> $GITHUB_OUTPUT  # No infrastructure changes
          elif [ "${{ steps.file-changes-check.outputs.terraform_files_changed }}" == "true" ]; then
            echo "Terraform files were modified - these are expected changes, not drift"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=expected" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT  # Plan shows changes
            if [ -f tfplan ]; then
              terraform show -no-color tfplan > change_summary.txt 2>/dev/null || echo "Could not read tfplan" > change_summary.txt
              echo "ðŸ“ Change summary saved (expected changes from code updates)"
            fi
          else
            echo "ðŸš¨ REAL DRIFT DETECTED - Infrastructure changed outside Terraform!"
            echo "Terraform files did NOT change, but plan shows changes."
            echo "This means infrastructure was modified manually or by another process."
            echo "drift_detected=true" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            echo "change_type=drift" >> $GITHUB_OUTPUT
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT  # Plan shows changes
            if [ -f tfplan ]; then
              terraform show -no-color tfplan > drift_summary.txt 2>/dev/null || echo "Could not read tfplan" > drift_summary.txt
              echo "ðŸš¨ Drift summary saved - requires immediate attention"
            fi
          fi

      - name: Get Server IP from State
        id: get-server-ip
        working-directory: infra/terraform
        run: |
          if [ -f terraform.tfstate ]; then
            SERVER_IP=$(terraform output -raw server_ip 2>/dev/null || echo "")
            if [ -z "$SERVER_IP" ]; then
              # Try to extract from state file
              SERVER_IP=$(grep -o '"public_ip":"[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
            fi
            echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          else
            echo "server_ip=" >> $GITHUB_OUTPUT
          fi

      - name: Send Drift Email (Real Drift Only)
        if: steps.drift-check.outputs.change_type == 'drift'
        run: |
          echo "ðŸš¨ Sending drift alert email..."
          chmod +x ./infra/ci-cd/scripts/email-notification.sh
          ./infra/ci-cd/scripts/email-notification.sh "$(cat infra/terraform/drift_summary.txt)"
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Log Expected Changes
        if: steps.drift-check.outputs.change_type == 'expected'
        run: |
          echo "â„¹ï¸  Expected changes detected (Terraform files were modified)"
          echo "Proceeding with deployment without drift alert..."
          echo ""
          echo "Changes will be applied:"
          echo "---"
          head -50 infra/terraform/change_summary.txt || echo "Change summary not available"

      - name: Manual Approval for Real Drift (Only)
        if: steps.drift-check.outputs.change_type == 'drift'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          minimum-approvals: 1
          issue-title: "ðŸš¨ REAL DRIFT DETECTED - Infrastructure Changed Outside Terraform"
          issue-body: |
            **âš ï¸ CRITICAL: Real Infrastructure Drift Detected**
            
            Infrastructure has been modified **outside of Terraform**. This is unexpected and requires investigation.
            
            **What happened:**
            - Terraform code files were **NOT modified**
            - But infrastructure plan shows changes
            - This indicates manual changes or changes from another process
            
            **Action Required:**
            1. Review the plan below
            2. Investigate what caused the drift
            3. Approve if changes are intentional, or revert if unauthorized
            
            **Plan Summary:**
            ```
            ${{ steps.drift-check.outputs.drift_summary }}
            ```
            
            **Note:** No Terraform files were changed in this commit, confirming this is real drift.
            
            **Next Steps:**
            - Approve to apply these changes
            - Or investigate and revert unauthorized changes
          issue-create-on-fail: false
        continue-on-error: true
        id: manual-approval

      - name: Log first run
        if: steps.drift-check.outputs.change_type == 'first_run'
        run: |
          echo "âœ… First infrastructure deployment - proceeding without approval"

      - name: Terraform Apply
        if: |
          steps.drift-check.outputs.change_type == 'first_run' ||
          steps.drift-check.outputs.change_type == 'none' ||
          steps.drift-check.outputs.change_type == 'expected' ||
          (steps.drift-check.outputs.change_type == 'drift' && steps.manual-approval.outcome == 'success')
        working-directory: infra/terraform
        run: |
          if [ "${{ steps.drift-check.outputs.change_type }}" == "drift" ]; then
            echo "âš ï¸  Applying changes after drift approval..."
          elif [ "${{ steps.drift-check.outputs.change_type }}" == "expected" ]; then
            echo "âœ… Applying expected changes from Terraform code updates..."
          elif [ "${{ steps.drift-check.outputs.change_type }}" == "first_run" ]; then
            echo "ðŸš€ Applying first infrastructure deployment..."
          else
            echo "â„¹ï¸  No changes to apply"
          fi
          terraform apply -auto-approve tfplan

      - name: Upload Terraform State
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/terraform.tfstate
          retention-days: 90  # Increased from 1 to 90 days to prevent state loss
          if-no-files-found: ignore

  ansible-deploy:
    name: Ansible Deployment
    runs-on: ubuntu-latest
    needs: terraform-plan
    # Only run Ansible if:
    # 1. Ansible files changed (playbook/roles updated), OR
    # 2. Infrastructure actually changed (new instance, etc.), OR
    # 3. First run (infrastructure being created for the first time)
    if: |
      needs.terraform-plan.outputs.ansible_files_changed == 'true' ||
      needs.terraform-plan.outputs.infrastructure_changed == 'true' ||
      needs.terraform-plan.outputs.change_type == 'first_run'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/

      - name: Get Server IP from Terraform Output
        id: get-server-ip
        working-directory: infra/terraform
        run: |
          echo "Checking for Terraform state file..."
          ls -la terraform.tfstate* 2>/dev/null || echo "No state files found"
          
          # Check if state file exists
          if [ ! -f terraform.tfstate ]; then
            echo "ERROR: terraform.tfstate file not found"
            exit 1
          fi
          
          # Initialize Terraform to read outputs
          terraform init -backend=false || true
          
          # Try to get server IP from Terraform output
          echo "Trying Terraform output..."
          SERVER_IP=$(terraform output -raw server_ip 2>/dev/null || echo "")
          echo "Terraform output result: '$SERVER_IP'"
          
          # Fallback 1: Extract from state file using jq (if available) or grep
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ]; then
            echo "Extracting server IP from state file using jq..."
            if command -v jq &> /dev/null; then
              SERVER_IP=$(jq -r '.resources[] | select(.type == "aws_instance") | .instances[0].attributes.public_ip // empty' terraform.tfstate 2>/dev/null | head -1 || echo "")
            fi
          fi
          
          # Fallback 2: Extract using grep from state file
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ]; then
            echo "Extracting server IP from state file using grep..."
            SERVER_IP=$(grep -o '"public_ip":"[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
            # Also try with escaped quotes
            if [ -z "$SERVER_IP" ]; then
              SERVER_IP=$(grep -oP '"public_ip":\s*"\K[^"]+' terraform.tfstate | head -1 || echo "")
            fi
            # Try without quotes
            if [ -z "$SERVER_IP" ]; then
              SERVER_IP=$(grep -o 'public_ip[^"]*"[^"]*"\([0-9.]\+\)' terraform.tfstate | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' | head -1 || echo "")
            fi
          fi
          
          # Fallback 3: Query AWS directly - find by tag first (most reliable)
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ] || [ "$SERVER_IP" == "None" ]; then
            echo "Querying AWS for server IP by tag..."
            # Find instance by tag (most reliable method)
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=todo-app-server" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ] && [ "$INSTANCE_ID" != "null" ]; then
              echo "Found instance by tag: $INSTANCE_ID"
              SERVER_IP=$(aws ec2 describe-instances \
                --instance-ids "$INSTANCE_ID" \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text 2>/dev/null || echo "")
              echo "AWS query by tag result: '$SERVER_IP'"
            fi
          fi
          
          # Fallback 4: Query AWS using instance ID from state file
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ] || [ "$SERVER_IP" == "None" ]; then
            echo "Querying AWS using instance ID from state..."
            # Try to get instance ID from state file
            INSTANCE_ID=$(grep -o '"id":"i-[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
            if [ -z "$INSTANCE_ID" ]; then
              INSTANCE_ID=$(grep -oE 'i-[a-z0-9]{17}' terraform.tfstate | head -1 || echo "")
            fi
            
            echo "Found instance ID in state: '${INSTANCE_ID:-empty}'"
            
            if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "null" ] && [ "$INSTANCE_ID" != "None" ]; then
              echo "Querying AWS EC2 for public IP..."
              SERVER_IP=$(aws ec2 describe-instances \
                --instance-ids "$INSTANCE_ID" \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text 2>/dev/null || echo "")
              echo "AWS query by instance ID result: '$SERVER_IP'"
            fi
          fi
          
          # Final validation
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ] || [ "$SERVER_IP" == "None" ] || [ "$SERVER_IP" == "-" ]; then
            echo "ERROR: Could not determine server IP address"
            echo "Debugging info:"
            echo "State file exists: $([ -f terraform.tfstate ] && echo 'yes' || echo 'no')"
            echo "State file size: $(wc -c < terraform.tfstate) bytes"
            echo "First 500 chars of state file:"
            head -c 500 terraform.tfstate || true
            exit 1
          fi
          
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "âœ“ Server IP: $SERVER_IP"

      - name: Setup SSH
        run: |
          if [ -z "${{ steps.get-server-ip.outputs.server_ip }}" ]; then
            echo "ERROR: Server IP is empty. Cannot setup SSH."
            exit 1
          fi
          
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-server-ip.outputs.server_ip }} >> ~/.ssh/known_hosts

      - name: Install Ansible
        # Ansible is required for deployment, but GitHub Actions runners are ephemeral
        # so we need to install it each time. However, we can optimize by using pip
        # which is faster than apt-get, or check if it's already available.
        run: |
          if ! command -v ansible &> /dev/null; then
            echo "Installing Ansible..."
            sudo apt-get update -qq
            sudo apt-get install -y ansible
          else
            echo "Ansible already installed: $(ansible --version | head -1)"
          fi

      - name: Generate Ansible Inventory
        run: |
          mkdir -p infra/ansible/inventory
          cat > infra/ansible/inventory/hosts.yml <<EOF
          all:
            hosts:
              todo-app-server:
                ansible_host: ${{ steps.get-server-ip.outputs.server_ip }}
                ansible_user: ubuntu
                ansible_ssh_private_key_file: ~/.ssh/id_rsa
                ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
          EOF
          echo "Generated inventory file:"
          cat infra/ansible/inventory/hosts.yml

      - name: Wait for SSH
        run: |
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@${{ steps.get-server-ip.outputs.server_ip }} 'echo "SSH ready"'; then
              echo "SSH is ready!"
              exit 0
            fi
            echo "Attempt $i/30: SSH not ready yet, waiting 10 seconds..."
            sleep 10
          done
          echo "SSH failed to become available"
          exit 1

      - name: Run Ansible Playbook
        run: |
          cd infra/ansible
          ansible-playbook -i inventory/hosts.yml playbook.yml
        env:
          ANSIBLE_HOST_KEY_CHECKING: False
          ANSIBLE_SSH_PRIVATE_KEY_FILE: ~/.ssh/id_rsa

