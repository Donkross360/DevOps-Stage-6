name: Infrastructure Deployment

on:
  push:
    paths:
      - 'infra/terraform/**'
      - 'infra/ansible/**'
  pull_request:
    paths:
      - 'infra/terraform/**'
      - 'infra/ansible/**'
  workflow_dispatch:

# Prevent duplicate runs - cancel in-progress runs when a new one starts
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  terraform-plan:
    name: Terraform Plan & Drift Detection
    runs-on: ubuntu-latest
    outputs:
      drift_detected: ${{ steps.drift-check.outputs.drift_detected }}
      server_ip: ${{ steps.get-server-ip.outputs.server_ip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init

      - name: Remove null_resource from state if exists (for count transition)
        working-directory: infra/terraform
        run: |
          if [ -f terraform.tfstate ]; then
            # Remove null_resource from state if it exists (handles transition to count-based resource)
            terraform state list 2>/dev/null | grep -E "null_resource.ansible_provision(\[0\])?$" | while read resource; do
              echo "Removing $resource from state..."
              terraform state rm "$resource" || true
            done
          fi
        continue-on-error: true

      - name: Create terraform.tfvars from GitHub Secrets
        working-directory: infra/terraform
        run: |
            cat > terraform.tfvars <<EOF
            aws_region = "${{ secrets.AWS_REGION || 'us-east-1' }}"
            instance_type = "${{ secrets.TERRAFORM_INSTANCE_TYPE || 't3.medium' }}"
            key_pair_name = "${{ secrets.TERRAFORM_KEY_PAIR_NAME }}"
            ssh_key_path = "${{ secrets.TERRAFORM_SSH_KEY_PATH || '~/.ssh/id_rsa' }}"
            ssh_cidr = "${{ secrets.TERRAFORM_SSH_CIDR || '0.0.0.0/0' }}"
            server_user = "${{ secrets.TERRAFORM_SERVER_USER || 'ubuntu' }}"
            state_volume_size = ${{ secrets.TERRAFORM_STATE_VOLUME_SIZE || 10 }}
            availability_zone = ""
            skip_ansible_provision = true
            EOF

      - name: Import existing security group (if exists)
        working-directory: infra/terraform
        run: |
          # Try to find existing security group by name
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=todo-app-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            echo "Found existing security group: $SG_ID"
            # Check if already in state
            if ! terraform state show aws_security_group.todo_app 2>/dev/null; then
              echo "Importing existing security group into Terraform state..."
              terraform import -var-file=terraform.tfvars aws_security_group.todo_app "$SG_ID" || echo "Import failed, will create new one"
            else
              echo "Security group already in Terraform state"
            fi
          else
            echo "No existing security group found"
          fi
        continue-on-error: true

      - name: Import existing EC2 instance (if exists)
        working-directory: infra/terraform
        run: |
          # Try to find existing EC2 instance by tag Name=todo-app-server
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=todo-app-server" "Name=instance-state-name,Values=running,stopped,stopping" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
            echo "Found existing EC2 instance: $INSTANCE_ID"
            # Check if already in state
            if ! terraform state show aws_instance.todo_app 2>/dev/null; then
              echo "Importing existing EC2 instance into Terraform state..."
              terraform import -var-file=terraform.tfvars aws_instance.todo_app "$INSTANCE_ID" || echo "Import failed, will create new one"
              
              # Also check for and import associated EBS volume if it exists
              echo "Checking for associated EBS volume..."
              VOL_ID=$(aws ec2 describe-volumes \
                --filters "Name=attachment.instance-id,Values=$INSTANCE_ID" "Name=tag:Name,Values=terraform-state-storage" \
                --query 'Volumes[0].VolumeId' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$VOL_ID" ] && [ "$VOL_ID" != "None" ]; then
                echo "Found associated EBS volume: $VOL_ID"
                # Import EBS volume if not in state
                if ! terraform state show aws_ebs_volume.terraform_state 2>/dev/null; then
                  echo "Importing EBS volume into Terraform state..."
                  terraform import -var-file=terraform.tfvars aws_ebs_volume.terraform_state "$VOL_ID" || echo "EBS volume import failed"
                fi
                # Import volume attachment format: <volume_id>:<instance_id>:<device>
                if ! terraform state show aws_volume_attachment.terraform_state 2>/dev/null; then
                  DEVICE=$(aws ec2 describe-volumes --volume-ids "$VOL_ID" --query 'Volumes[0].Attachments[0].Device' --output text 2>/dev/null || echo "/dev/sdf")
                  echo "Importing volume attachment: $VOL_ID:$INSTANCE_ID:$DEVICE"
                  terraform import -var-file=terraform.tfvars aws_volume_attachment.terraform_state "${VOL_ID}:${INSTANCE_ID}:${DEVICE}" || echo "Volume attachment import failed"
                fi
              fi
            else
              echo "EC2 instance already in Terraform state"
            fi
          else
            echo "No existing EC2 instance found"
          fi
        continue-on-error: true

      - name: Remove existing null_resource from state (if needed)
        working-directory: infra/terraform
        run: |
          # Remove null_resource from state if it exists (when switching from count=1 to count=0)
          terraform state list 2>/dev/null | grep -q "null_resource.ansible_provision" && \
            terraform state rm null_resource.ansible_provision 2>/dev/null || \
            echo "null_resource.ansible_provision not in state or already removed"
        continue-on-error: true

      - name: Terraform Plan
        working-directory: infra/terraform
        run: terraform plan -out=tfplan -var-file=terraform.tfvars
        continue-on-error: true

      - name: Check for Drift
        id: drift-check
        working-directory: infra/terraform
        run: |
          # Check if this is a first run (no existing state)
          if [ ! -f terraform.tfstate ] || [ ! -s terraform.tfstate ]; then
            echo "First run detected - no existing state"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=true" >> $GITHUB_OUTPUT
          elif terraform show -no-color tfplan | grep -q "No changes"; then
            echo "No drift detected"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
          else
            echo "Drift detected - existing infrastructure has changes"
            echo "drift_detected=true" >> $GITHUB_OUTPUT
            echo "is_first_run=false" >> $GITHUB_OUTPUT
            terraform show -no-color tfplan > drift_summary.txt
          fi

      - name: Get Server IP from State
        id: get-server-ip
        working-directory: infra/terraform
        run: |
          if [ -f terraform.tfstate ]; then
            SERVER_IP=$(terraform output -raw server_ip 2>/dev/null || echo "")
            if [ -z "$SERVER_IP" ]; then
              # Try to extract from state file
              SERVER_IP=$(grep -o '"public_ip":"[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
            fi
            echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          else
            echo "server_ip=" >> $GITHUB_OUTPUT
          fi

      - name: Send Drift Email
        if: steps.drift-check.outputs.drift_detected == 'true'
        run: |
          chmod +x ./infra/ci-cd/scripts/email-notification.sh
          ./infra/ci-cd/scripts/email-notification.sh "$(cat infra/terraform/drift_summary.txt)"
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}

      - name: Manual Approval (skip on first run or if Issues disabled)
        if: steps.drift-check.outputs.drift_detected == 'true' && steps.drift-check.outputs.is_first_run != 'true'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          minimum-approvals: 1
          issue-title: "Terraform Drift Detected - Approval Required"
          issue-body: |
            Terraform drift has been detected. Please review the plan and approve.
            
            Plan Summary:
            ```
            ${{ steps.drift-check.outputs.drift_summary }}
            ```
          issue-create-on-fail: false
        continue-on-error: true
        id: manual-approval

      - name: Log first run
        if: steps.drift-check.outputs.is_first_run == 'true'
        run: |
          echo "First infrastructure deployment - proceeding without approval"

      - name: Terraform Apply
        if: |
          steps.drift-check.outputs.drift_detected != 'true' || 
          steps.drift-check.outputs.is_first_run == 'true' ||
          (steps.drift-check.outputs.drift_detected == 'true' && steps.drift-check.outputs.is_first_run != 'true' && steps.manual-approval.outcome == 'success')
        working-directory: infra/terraform
        run: terraform apply -auto-approve tfplan

      - name: Upload Terraform State
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/terraform.tfstate
          retention-days: 1
          if-no-files-found: ignore

  ansible-deploy:
    name: Ansible Deployment
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: infra/terraform/

      - name: Get Server IP from Terraform Output
        id: get-server-ip
        working-directory: infra/terraform
        run: |
          # Initialize Terraform to read outputs
          terraform init -backend=false 2>/dev/null || true
          
          # Try to get server IP from output
          SERVER_IP=$(terraform output -raw server_ip 2>/dev/null || echo "")
          
          # Fallback: extract from state file
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ]; then
            echo "Extracting server IP from state file..."
            SERVER_IP=$(grep -o '"public_ip":"[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
          fi
          
          # Additional fallback: query AWS directly
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ]; then
            echo "Querying AWS for server IP..."
            INSTANCE_ID=$(grep -o '"id":"i-[^"]*"' terraform.tfstate | head -1 | cut -d'"' -f4 || echo "")
            if [ -n "$INSTANCE_ID" ]; then
              SERVER_IP=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "")
            fi
          fi
          
          if [ -z "$SERVER_IP" ] || [ "$SERVER_IP" == "null" ] || [ "$SERVER_IP" == "None" ]; then
            echo "ERROR: Could not determine server IP address"
            exit 1
          fi
          
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "Server IP: $SERVER_IP"

      - name: Setup SSH
        run: |
          if [ -z "${{ steps.get-server-ip.outputs.server_ip }}" ]; then
            echo "ERROR: Server IP is empty. Cannot setup SSH."
            exit 1
          fi
          
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-server-ip.outputs.server_ip }} >> ~/.ssh/known_hosts

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible

      - name: Wait for SSH
        run: |
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@${{ steps.get-server-ip.outputs.server_ip }} 'echo "SSH ready"'; then
              echo "SSH is ready!"
              exit 0
            fi
            echo "Attempt $i/30: SSH not ready yet, waiting 10 seconds..."
            sleep 10
          done
          echo "SSH failed to become available"
          exit 1

      - name: Run Ansible Playbook
        run: |
          cd infra/ansible
          ansible-playbook -i inventory/hosts.yml playbook.yml
        env:
          ANSIBLE_HOST_KEY_CHECKING: False
          ANSIBLE_SSH_PRIVATE_KEY_FILE: ~/.ssh/id_rsa

